function export_edr_xml(samples, samplerate, startDate, outPath)
%export_edr_xml generates an output .xml file compatible with the EDR-format

% Author: Richard Jumar
% Institute for Automation and applied Informatics,
% Karlsruhe Institute of Technology
% Email address: richard.jumar@kit.edu
% Website: https://www.iai.kit.edu/
% Last revision: 27.09.2021

% Modifications added by Ellen FÃ¶rstner
% on 17.08.21

%--------------------------------------------------------------------------

% Beware: EDR_ScopeFromFile does not like EDR0000 and missing
% EDR-designations. Doing so results in "no data" warning.
fileNameBase ="KIT-EDR-FAKELOGMOD_EDR9999_T";
CHnames = ["La";"Lb";"Lc";"Lia";"Lib";"Lic";"Ln"];
CHunits = ["V";"V";"V";"A";"A";"A";"A"];
scaleFactor = 42;
offset = 10;


%%
%for n-dimensional input: transpose the thing, 
% so that sample are oriented like this
% t L1 L2 L3 L4
% 0 
% 1
% 2
[a, b] = size(samples);
if b > a
    samples = transpose(samples);
    nbrCols = a;
else
    nbrCols = b;
end

%% Generate "capture Type" entry automatically (EF)
% Set capture type depending on number of channels
% We always use channel types that use PPS

switch (nbrCols)
        case 1
            captureType = 2;
        case 2
            captureType = 21;
        case 3
            captureType = 4;
        case 6
            captureType = 6;
        case 7
            captureType = 44;
        otherwise
            warning('Unrecognized number of columns, can not asign capture type')
            captureType = 55; % will cause warning in edr_single_xml.m
end

% reshape the input data to j(minutes) times k(seconds) worth of data
% reshape according to sampling rate:
% find number of whole seconds of data
lenInSec = floor(length(samples)/samplerate);
lenInMin = ceil(lenInSec / 60);

lenRest = mod(length(samples),samplerate);
if(lenRest ~= 0)
    warning("We allow only full seconds of data. Got " ...
        + string(lenRest) + " extra sample(s). Omitting these");
end

%cut to length;
samples = samples(1:lenInSec*samplerate,:);
%rehape to be accessible like this(VectorOfsamples, currentSecond, channel);
samples = reshape(samples,[samplerate,lenInSec,nbrCols]);

 disp('The content of signal has the following size (#samplesPerBlock, #seconds, #channels)')
 disp(size(samples))

% EF variable that is increase whenever a new second of data was used 
% -> make sure to use data only once
currentSecond = 0; 

for m = 1:lenInMin
    
%    disp(['  looking at minute ',num2str(m)])   
    fileDate = startDate + minutes(m-1);
    fileName = fileNameBase + datestr(fileDate,'yyyymmdd-HHMM') +".xml";
    fid = fopen(string(outPath) +"/"+fileName,'wt');
    fprintf(fid, "<?xml version=\""1.0\"" encoding=\""utf-8\"" standalone=""yes""?>\n" +...
        "<!-- KIT-Scope Raw measurements -->\n" +...
        "<!-- File created by export_edr_xml.m v1.1 (26.03.2021) -->\n" +...
        "<!-- Karlsruhe Institute of Technology (KIT), Germany -->\n" +...
        "<!-- Contact: richard.jumar / heiko.maass@kit.edu -->\n" +...
        "<!-- File created: " + datestr(now,'dd.mm.yyyy HH:MM:ss')+" -->\n\n" +...
        "<KIT_SCOPE_RAWDATALOG>\n" );
    
    % EF: Allows non-full minutes at end
    if m < lenInMin % wohle minute
        secInMin = 60;
    else % m = lenInMin las minute
        secInMin = lenInSec-(lenInMin-1)*60;
%         disp(['  This last minute contains ', num2str(secInMin), ' seconds.'])
    end
    for s = 1:secInMin
        
        currentSecond = currentSecond +1; % EF Added currentSecond variable
%        disp(['    looking at second ',num2str(s)])
        blockDate = fileDate + seconds(s);
        
        fprintf(fid, "\n<EDR_RAW_DATA>\n" +...
            "<sys_datetime>" + datestr(blockDate,'yyyy-mm-ddZTHH:MM:ss') + "</sys_datetime>\n" +...
            "<sys_datetime_ms>000</sys_datetime_ms>\n"+... 
            "<MAC>00-00-00-00-00-00</MAC>\n"+...
            "<unit>EDR9999</unit>\n"+...
            "<campaign>FAKE01</campaign>\n"+...
            "<NTP>\n"+...
            "<offset>0.0</offset>\n"+...
            "<deviation>0.0</deviation>\n"+...
            "<reliability>4</reliability>\n"+...
            "</NTP>\n"+...
            "<GPS>\n"+...
            "<gps_datetime>" + datestr(blockDate,'yyyy-mm-ddZTHH:MM:ss') + "</gps_datetime>\n"+...
            "<gps_datetime_ms>001</gps_datetime_ms>\n"+...
            "<timeValid>1</timeValid>\n"+...
            "<dateValid>1</dateValid>\n"+...
            "<ppsValid>1</ppsValid>\n"+...
            "<satNumber>7</satNumber>\n"+...
            "<gpsOffset valid=\""1\"">0.1405</gpsOffset>\n"+...
            "</GPS>\n"+...
            "<acquisition>\n"+...
            "<acq_datetime>" + datestr(blockDate,'yyyy-mm-ddZTHH:MM:ss') + "</acq_datetime>\n"+...
            "<acq_datetime_ms>0,000</acq_datetime_ms>\n"+...
            "<local_datetime>" + datestr(blockDate,'yyyy-mm-ddZTHH:MM:ss') + "</local_datetime>\n"+...
            "<local_datetime_ms>0</local_datetime_ms>\n"+...
            "<system_datetime>" + datestr(blockDate,'yyyy-mm-ddZTHH:MM:ss') + "</system_datetime>\n"+...
            "<system_datetime_ms>0</system_datetime_ms>\n"+...
            "<real_datetime>" + datestr(blockDate,'yyyy-mm-ddZTHH:MM:ss') + "</real_datetime>\n"+...
            "<real_datetime_ms>0,000</real_datetime_ms>\n"+...
            "<realTimeUsedOffset>0.0000</realTimeUsedOffset>\n"+...
            "<realTimeReliability>10</realTimeReliability>\n"+...
            "<timesource>PPS,GPS,NTP</timesource>\n"+...
            "<PPSstatus>PPsIntervalOk</PPSstatus>\n"+...
            "<samplesSinceLastEndIndex>0</samplesSinceLastEndIndex>\n"+...
            "<PPSsync>1</PPSsync>\n"+...
            "<PPS_Filter active=\""1\"" R=\""15000\"" C=\""0.022\"">\n"+...
            "<PPSpreTriggerTime_ms>0.0</PPSpreTriggerTime_ms>\n"+...
            "<PPSpreTriggerSamples>0.0</PPSpreTriggerSamples>\n"+...
            "<PPSnextPreTriggerTime_ms>-0.0</PPSnextPreTriggerTime_ms>\n"+...
            "<PPSnextPreTriggerSamples>-0.0</PPSnextPreTriggerSamples>\n"+...
            "<TimePerSingleSample_ms>0.0</TimePerSingleSample_ms>\n"+...
            "<NrRealSamples>" + samplerate + "</NrRealSamples>\n"+...
            "</PPS_Filter>\n"+...
            "<rounded_ms>0</rounded_ms>\n"+...
            "<function>\""((((double)data[uShort16] / 0xffff) * voltageRange - offset) * scalefactor\""</function>\n"+...
            "<InternalTemperature>37.00</InternalTemperature>\n"+...
            "<DAQ-board></DAQ-board>\n"+...
            "<DAQ-SerNr>FAKE</DAQ-SerNr>\n"+...
            "<samplesPerSecond>" + samplerate + "</samplesPerSecond>\n"+...
            "<evaluationVersion>2.67</evaluationVersion>\n"+...
            "<hardwareAcquisitionError>0</hardwareAcquisitionError>\n"+...
            "<dataRepresentation>2byte,base64</dataRepresentation>\n"+...
            "<byteorder0x12345678><![CDATA[eFY0Eg==]]></byteorder0x12345678>\n"+...
            "<channelCount>0</channelCount>\n"+...
            "<captureType>" + captureType + "</captureType>\n"+...
            "</acquisition>\n");
            
            for q = 1: nbrCols
                fprintf(fid, "<data chnr=\"""+ q +"\"" name=\""" + CHnames(q) + "\"" samples=\""" + samplerate + ...
                "\"" scaleFactor=\""" + scaleFactor + "\"" offset=\""10\"" voltageRange=\""20\"" unit=\""" + ...
                CHunits(q) + "\""><![CDATA[");
            
%                 disp(['    writing ',num2str(length(samples(:,m*s,q))),' samples to file for this second.'])
                
                adcVal = ((samples(:,currentSecond,q) / scaleFactor) + offset)/20 * 65536; % EF: added currentSecond variable
                %rounding and limiting is included in cast... 
                adcVal = uint16(adcVal);
                %double the length of array by converting 16 bit into two
                %times 8 bit
                adcVal = typecast(adcVal, 'uint8');                                
                % special legacy support for EDR: Current EDR versions put
                % an additional byte at the end of the stream of samples.
                % Reason: Unknown. But if we don't replicate the behavior,
                % the last sample will be read incorrectly by the EDR-ScopeFromFile
                % Therefore, do
                b64string = base64encode_rju1([adcVal; uint8(0)],'matlab');
                % instead of
                %b64string = base64encode_rju1([adcVal;],'matlab');
                % until this is fixed.
                fprintf(fid, b64string + "]]></data>\n");
            end
            
            fprintf(fid,"</EDR_RAW_DATA>\n\n");
    end
    
    fprintf(fid, "</KIT_SCOPE_RAWDATALOG>\n" + ...
        "<!-- File closed: "+ datestr(now,'dd.mm.yyyy HH:MM:ss')+" -->\n");
    fclose(fid);
end
if ~(currentSecond == lenInSec) % EF Added test with currentSecond variable (was all data used?)
    error(['Number of written seconds (',num2str(currentSecond),') does not equal total number of seconds (',...
        num2str(lenInSec),') in file. Check code!'])
end
end

